spine class Node : Id
  val key : int
  spec next : Node

  def init(key : int) : unit
    this.key = key
  end
end

lockfree trait Insert
  require val tail : Node
  require def search(key : int) : (Node, Node)

  def insert(key : int) : bool
    var newNode = new Node(key)
    while true do
      match this.search(key) with
        case (l, r) =>
          if ((r != this.tail) && (r.key == key)) then
            -- The element was already in the list, fail
            return false
          else
            newNode.next = r
            -- Try to insert the element
            if(CAT(l.next, r, newNode)) then
              return true
            end
          end
        end
      end
    end
    false -- This should never happen
  end
end

lockfree trait Delete
  require val tail : Node
  require def search(key : int) : (Node, Node)

  def delete(key : int) : bool
    while true do
      match this.search(key) with
        case (l, r) =>
          if ((r == this.tail) || (r.key != key)) then
            return false
          end

          if (not isStable(r.next)) then
            if(fix(r.next)) then
              if (not CAT(l.next, r, r.next)) then
                this.search(r.key)
              end
              return true
            end
          end
        end
      end
    end
    false -- This should never happen
  end
end

lockfree trait Find
  require val tail : Node
  require def search(key : int) : (Node, Node)

  def find(key : int) : bool
    match this.search(key) with
      case (l, r) =>
        if(r == this.tail || r.key != key) then
          return false
        else
          return true
        end
      end
    end
  end
end

class List : Insert(head) * Delete(head) * Find(head)
  val head : Node
  val tail : Node

  def init() : unit
    var dummyHead = new Node(0)
    var dummyTail = new Node(-1)
    dummyHead.next = consume dummyTail
    this.tail = speculate dummyHead.next
    this.head = consume dummyHead
  end

  def search(key : int) : (Node, Node)
    var leftNode = null : Node
    var rightNode = null : Node

    while true do
      var t = this.head

      -- 1. Find left and right nodes
      while true do
        if(not isStable(t.next)) then
          leftNode = t
        end

        t = speculate t.next
        if (t == this.tail) then
           break
        end

        unless(isStable(t.next) || t.key < key) then
          break
        end
      end

      rightNode = t

      -- 2. Check that nodes are adjacent
      if (rightNode == leftNode.next) then
        unless (rightNode != this.tail && isStable(rightNode.next)) then
          return (leftNode, rightNode)
        end
      else
        -- Nodes are not adjacent
        val oldNext = speculate leftNode.next
        if (isStable(oldNext.next)) then
          -- leftNode.next has been removed
          -- Try to move it forward
          if (CAT(leftNode.next, oldNext, oldNext.next)) then
            unless (rightNode != this.tail && isStable(rightNode.next)) then
              return (leftNode, rightNode)
            end
          end
        else
          -- A new node has been inserted after leftNode, restart
          ()
        end
      end
    end
    return (null : Node, null : Node) -- Should never happen
  end
end

active class Inserter
  val l : List
  def init(l : List, count : int) : unit
    this.l = l
    this!insertLoop(count)
  end

  def insertLoop(count : int) : unit
    if count <= 0 then
      return
    else
      this.l.insert(count)
      this!insertLoop(count - 1)
    end
  end
end

active class Finder
  val l : List
  def init(l : List, count : int) : unit
    this.l = l
    this!findLoop(count)
  end

  def findLoop(count : int) : unit
    if count <= 0 then
      return
    else
      this.l.find(count)
      this!findLoop(count - 1)
    end
  end
end

active class Deleter
  val l : List
  def init(l : List, count : int) : unit
    this.l = l
    this!deleteLoop(count)
  end

  def deleteLoop(count : int) : unit
    if count <= 0 then
      return
    else
      if this.l.delete(count) then
        println("Deleted {}", count)
      end
      this!deleteLoop(count - 1)
    end
  end
end

active class Main
  def main() : unit
    val l = new List()
    val nInserters = 2
    val nFinders = 2
    val nDeleters = 2
    repeat i <- nInserters do
      new Inserter(l, 20)
    end
    repeat i <- nFinders do
      new Finder(l, 20)
    end
    repeat i <- nDeleters do
      new Deleter(l, 20)
    end
  end
end
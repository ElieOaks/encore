linear class Elem : Id
  val elem : int
  def init(elem : int) : unit
    this.elem = elem
  end
end

spine class Node : Id
  val key : int
  var elem : Elem
  spec next : Node

  def init(key : int, var elem : Elem) : unit
    this.key = key
    this.elem = consume elem
  end
end

lockfree trait Insert
  require val tail : Node
  require def search(key : int) : (Node | elem, Node | elem)

  def insert(key : int, var elem : Elem) : Elem
    var newNode = new Node(key, consume elem)
    while true do
      match this.search(key) with
        case (l, r) =>
          if ((r != this.tail) && (r.key == key)) then
            -- The element was already in the list, fail
            return consume newNode.elem
          else
            newNode.next = r
            -- Try to insert the element
            if(CAT(l.next, newNode.next, newNode)) then
              return (null : Elem)
            end
          end
        end
      end
    end
    null -- This should never happen
  end
end

lockfree trait Delete
  require val tail : Node
  require def search(key : int) : (Node | elem, Node | elem)

  def delete(key : int) : Elem
    while true do
      match this.search(key) with
        case (l, r) =>
          if ((r == this.tail) || (r.key != key)) then
            return (null : Elem)
          end
          if (not isStable(r.next)) then
            if(fix(r.next)) then
              if (CAT(l.next, r, r.next)) then
                return consume r.elem
                () -- Only to satisfy typechecker
              else
                this.search(r.key)
              end
            end
          end
        end
      end
    end
    null -- This should never happen
  end
end

lockfree trait Find
  require val tail : Node
  require def search(key : int) : (Node | elem, Node | elem)

  def find(key : int) : bool
    match this.search(key) with
      case (l, r) =>
        if(r == this.tail || r.key != key) then
          return false
        else
          return true
        end
      end
    end
  end
end

class List : Insert(head) * Delete(head) * Find(head)
  val head : Node | elem
  val tail : Node | elem

  def init() : unit
    var dummyHead = new Node(0, null)
    var dummyTail = new Node(-1, null)
    dummyHead.next = consume dummyTail
    this.tail = speculate dummyHead.next
    this.head = consume dummyHead
  end

  def search(key : int) : (Node | elem, Node | elem)
    var leftNode = null : Node | elem
    var rightNode = null : Node | elem

    while true do
      var t = this.head

      -- 1. Find left and right nodes
      while true do
        if(not isStable(t.next)) then
          leftNode = t
        end
        t = speculate t.next
        if (t == this.tail) then
           break
        end
        unless(isStable(t.next) || t.key < key) then
          break
        end
      end
      rightNode = t

      -- 2. Check that nodes are adjacent
      if (rightNode == leftNode.next) then
        unless (rightNode != this.tail && isStable(rightNode.next)) then
          return (leftNode, rightNode)
        end
      else
        -- Nodes are not adjacent
        val oldNext = speculate leftNode.next
        if (isStable(oldNext.next)) then
          -- leftNode.next has been removed
          -- Try to move it forward
          if (CAT(leftNode.next, oldNext, oldNext.next)) then
            unless (rightNode != this.tail && isStable(rightNode.next)) then
              return (leftNode, rightNode)
            end
          end
        else
          -- A new node has been inserted after leftNode, restart
          ()
        end
      end
    end
    return (null : Node | elem, null : Node | elem) -- Should never happen
  end
end

active class Inserter
  var l : List
  def init(l : List, count : int) : unit
    this.l = l
    this!insertLoop(count)
  end

  def insertLoop(count : int) : unit
    if count <= 0 then
      return
    else
      this.l.insert(count, new Elem(count * 100))
      this!insertLoop(count - 1)
    end
  end
end

active class Finder
  val l : List
  def init(l : List, count : int) : unit
    this.l = l
    this!findLoop(count)
  end

  def findLoop(count : int) : unit
    if count <= 0 then
      return
    else
      this.l.find(count)
      this!findLoop(count - 1)
    end
  end
end

active class Deleter
  val l : List
  def init(l : List, count : int) : unit
    this.l = l
    this!deleteLoop(count)
  end

  def deleteLoop(count : int) : unit
    if count <= 0 then
      return
    else
      val ret = this.l.delete(count)
      if ret != null then
        println("Deleted ({}, {})\n", count, ret.elem)
      else
        println("Key {} was not in the list", count)
      end
      this!deleteLoop(count - 1)
    end
  end
end

active class Main
  def main() : unit
    val l = new List()
    val nInserters = 2
    val nFinders = 2
    val nDeleters = 2
    repeat i <- nInserters do
      new Inserter(l, 20)
    end
    repeat i <- nFinders do
      new Finder(l, 20)
    end
    repeat i <- nDeleters do
      new Deleter(l, 20)
    end
  end
end